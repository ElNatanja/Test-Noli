--// VOIDSTAR SCRIPT COMPLETO

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

local R6PartNames = {
	["Head"] = true, ["Torso"] = true, ["Left Arm"] = true,
	["Right Arm"] = true, ["Left Leg"] = true,
	["Right Leg"] = true, ["HumanoidRootPart"] = true
}

local meshAttachmentMap = {
	["NoliHead"] = "Head", ["NoliLeft Arm"] = "Left Arm",
	["NoliLeft Leg"] = "Left Leg", ["NoliLower Skull"] = "Head",
	["NoliRight Arm"] = "Right Arm", ["NoliRight Leg"] = "Right Leg",
	["NoliTorso"] = "Torso", ["Voidstar"] = "Right Arm",
	["VoidstarCrown"] = "Head"
}

local headOffsets = {
	["NoliLower Skull"] = CFrame.new(0, -0.25, 0),
	["VoidstarCrown"] = CFrame.new(0, 1.05, 0),
	["NoliHead"] = CFrame.new(0.3, 0, 0),
	["Voidstar"] = CFrame.new(-0.8, -1.5, -0.5)
}

local voidstarMotor, voidstarOriginal, voidstarThrown = nil, nil, nil
local soundId = "rbxassetid://99558901806521"

local function weldAccessory(partToAttach, accessory)
	if accessory.Name == "Voidstar" then
		local motor = Instance.new("Motor6D")
		motor.Name = "VoidstarMotor6D"
		motor.Part0 = partToAttach
		motor.Part1 = accessory
		motor.C0 = headOffsets[accessory.Name] or CFrame.new()
		motor.C1 = CFrame.new()
		motor.Parent = partToAttach
		voidstarMotor = motor
		accessory.Anchored = false
		accessory.CanCollide = false
		accessory.Parent = character
		voidstarOriginal = accessory
	else
		local weld = Instance.new("Weld")
		weld.Part0 = partToAttach
		weld.Part1 = accessory
		weld.C0 = headOffsets[accessory.Name] or CFrame.new()
		weld.Parent = accessory
		accessory.Anchored = false
		accessory.CanCollide = false
		accessory.Parent = character
	end
end

local function attachToCharacter(character, accessory)
	local attachName = meshAttachmentMap[accessory.Name]
	if not attachName then return end
	local targetPart = character:FindFirstChild(attachName)
	if not targetPart then return end
	weldAccessory(targetPart, accessory)
end

local function main()
	local assets = ReplicatedStorage:WaitForChild("Assets")
	local killers = assets:WaitForChild("Killers")
	local noliFolder = killers:WaitForChild("#NoliRework")
	local rig = noliFolder:WaitForChild("Rig2")

	if not character or not character.Parent then
		character = player.CharacterAdded:Wait()
	end

	for _, part in ipairs(character:GetChildren()) do
		if part:IsA("BasePart") and R6PartNames[part.Name] then
			part.Transparency = 1
			part.CanCollide = false
		end
	end

	for _, descendant in ipairs(rig:GetDescendants()) do
		if descendant:IsA("MeshPart") and meshAttachmentMap[descendant.Name] then
			local clone = descendant:Clone()
			attachToCharacter(character, clone)
			clone.Transparency = 0
			clone.CanCollide = false
		end
	end

	local rightArm = rig:FindFirstChild("Right Arm")
	if rightArm then
		for _, obj in ipairs(rightArm:GetChildren()) do
			if (obj:IsA("BasePart") or obj:IsA("MeshPart")) and obj.Name ~= "NoliRight Arm" then
				local clone = obj:Clone()
				local weld = Instance.new("Weld")
				weld.Part0 = character:FindFirstChild("Right Arm")
				weld.Part1 = clone
				weld.C0 = (clone.Name == "TentacleBase") and CFrame.new(0, -1, 0) or CFrame.new()
				weld.Parent = clone
				clone.Anchored = false
				clone.CanCollide = false
				clone.Parent = character
			end
		end
	end

	local hrp = rig:FindFirstChild("HumanoidRootPart")
	if hrp then
		local shadowPuddle = hrp:FindFirstChild("ShadowPuddle")
		if shadowPuddle and shadowPuddle:IsA("Attachment") then
			local hrpPlayer = character:FindFirstChild("HumanoidRootPart")
			if hrpPlayer then
				shadowPuddle:Clone().Parent = hrpPlayer
			end
		end
	end
end

main()

local elapsedTime, cycleDuration, maxRotationSpeed = 0, 2, 1000
local rotatingCycle = true

RunService.Heartbeat:Connect(function(dt)
	if not voidstarMotor then return end
	elapsedTime = elapsedTime + dt
	if elapsedTime > cycleDuration then
		elapsedTime -= cycleDuration
		rotatingCycle = not rotatingCycle
	end
	local alpha = rotatingCycle
		and math.sin((elapsedTime / cycleDuration) * math.pi / 2)
		or math.cos((elapsedTime / cycleDuration) * math.pi / 2)
	local currentSpeed = maxRotationSpeed * alpha
	voidstarMotor.C0 *= CFrame.Angles(math.rad(currentSpeed * dt), 0, 0)
end)

local function playSound(_)
	local sound = Instance.new("Sound")
	sound.SoundId = soundId
	sound.Volume = 1.5
	sound.Parent = character
	sound:Play()
	sound.Ended:Connect(function() sound:Destroy() end)
end

local function activateAppearEffects(voidstar)
	local appear1, appear2 = voidstar:FindFirstChild("Appear1"), voidstar:FindFirstChild("Appear2")
	local appearT = voidstar:FindFirstChild("AppearT")
	local appear3 = appearT and appearT:FindFirstChild("Appear3")
	local appear4 = appearT and appearT:FindFirstChild("Appear4")

	if appear3 then appear3.Enabled = true end
	if appear4 then appear4.Enabled = true end

	task.delay(2, function()
		if appear1 then appear1.Enabled = true end
		if appear2 then appear2.Enabled = true end

		task.delay(0.5, function()
			if appear3 then appear3.Enabled = false end
			if appear4 then appear4.Enabled = false end
		end)

		task.delay(2, function()
			if appear1 then appear1.Enabled = false end
			if appear2 then appear2.Enabled = false end
		end)
	end)
end

local function launchVoidstar()
	if voidstarThrown and voidstarThrown.Parent then
		playSound()
		voidstarThrown:Destroy()
		voidstarThrown = nil
	end

	if not voidstarOriginal then return end

	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	local closestPlayer, minDist = nil, math.huge
	for _, p in Players:GetPlayers() do
		if p ~= player and p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
			local dist = (p.Character.HumanoidRootPart.Position - hrp.Position).Magnitude
			if dist < minDist then
				minDist = dist
				closestPlayer = p
			end
		end
	end

	if not closestPlayer then return end

	task.delay(1, function()
		local copy = voidstarOriginal:Clone()
		copy.Anchored = false
		copy.CanCollide = true
		copy.Transparency = 0
		copy.CFrame = hrp.CFrame * CFrame.new(0, 0, -2)
		copy.Parent = workspace

		local velocity = (closestPlayer.Character.HumanoidRootPart.Position - hrp.Position).Unit * 35
		local bv = Instance.new("BodyVelocity")
		bv.MaxForce = Vector3.new(1e5, 1e5, 1e5)
		bv.Velocity = velocity
		bv.Parent = copy

		voidstarThrown = copy
		voidstarOriginal.Transparency = 1
		activateAppearEffects(voidstarOriginal)

		task.delay(1, function()
			voidstarOriginal.Transparency = 0
		end)

		task.delay(0.05, function()
			if not copy:IsDescendantOf(workspace) then return end
			copy.Touched:Connect(function(hit)
				local hPlayer = Players:GetPlayerFromCharacter(hit.Parent)
				if hPlayer and hPlayer ~= player and voidstarThrown then
					playSound()
					voidstarThrown:Destroy()
					voidstarThrown = nil
				elseif hit:IsA("BasePart") and hit.Parent == workspace and voidstarThrown then
					playSound()
					voidstarThrown:Destroy()
					voidstarThrown = nil
				end
			end)
		end)

		task.delay(2, function()
			if copy then
				copy.Transparency = 0
			end
		end)
	end)
end

local function rotateCopyWithAcceleration(copy, duration, targetSpeed)
	local elapsed = 0
	local speed = 0

	-- To update rotation each heartbeat while accelerating
	local connection
	connection = RunService.Heartbeat:Connect(function(dt)
		if not copy or not copy.Parent then
			connection:Disconnect()
			return
		end
		elapsed = elapsed + dt
		if elapsed > duration then elapsed = duration end

		-- Linear acceleration factor from 0 to 1
		local alpha = elapsed / duration
		speed = targetSpeed * alpha

		copy.CFrame *= CFrame.Angles(0, math.rad(speed * dt), 0)

		if elapsed >= duration then
			connection:Disconnect()
		end
	end)

	-- Return a function to keep rotating at full speed after acceleration
	return function(keepDuration)
		local fullSpeed = targetSpeed
		local fullElapsed = 0
		local conn2
		conn2 = RunService.Heartbeat:Connect(function(dt)
			if not copy or not copy.Parent then
				conn2:Disconnect()
				return
			end
			fullElapsed = fullElapsed + dt
			if fullElapsed > keepDuration then
				conn2:Disconnect()
				return
			end
			copy.CFrame *= CFrame.Angles(0, math.rad(fullSpeed * dt), 0)
		end)
	end
end

local function createCopyAndAnimate()
	if not voidstarOriginal then return end
	local hrp = character:FindFirstChild("Torso") or character:FindFirstChild("UpperTorso") or character:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	-- Crear copia justo delante del torso con offset 1.2 en Z
	local copy = voidstarOriginal:Clone()
	copy.Anchored = false
	copy.CanCollide = false
	copy.Transparency = 0
	copy.CFrame = hrp.CFrame * CFrame.new(0, 0, -1.2)
	copy.Parent = workspace

	-- Vincular para seguir el torso cada frame
	local followConnection
	followConnection = RunService.Heartbeat:Connect(function()
		if copy and copy.Parent and hrp and hrp.Parent then
			copy.CFrame = hrp.CFrame * CFrame.new(0, 0, -1.2)
		else
			if followConnection then
				followConnection:Disconnect()
			end
		end
	end)

	-- Activar efectos iguales a lanzar (particle emitters en voidstar original)
	activateAppearEffects(voidstarOriginal)
	voidstarOriginal.Transparency = 1
	task.delay(2, function()
		voidstarOriginal.Transparency = 0
	end)

	task.wait(1.2) -- esperar 1.2 segundos antes de acelerar rotación

	-- Rotar hacia la derecha a 2000 grados/s con aceleración en 0.1 s
	local keepRotateFunc = rotateCopyWithAcceleration(copy, 0.1, 2000)

	task.wait(0.1)

	-- Mantener rotación rápida 0.3 segundos
	keepRotateFunc(0.3)

	task.wait(0.3)

	-- Desconectar seguimiento para mover libremente
	if followConnection then
		followConnection:Disconnect()
	end

	-- Mover hacia dentro del torso en no más de 0.2 segundos
	local startCFrame = copy.CFrame
	local endCFrame = hrp.CFrame
	local moveDuration = 0.2
	local moveElapsed = 0

	while moveElapsed < moveDuration do
		local dt = RunService.Heartbeat:Wait()
		moveElapsed = moveElapsed + dt
		local alpha = math.clamp(moveElapsed / moveDuration, 0, 1)
		copy.CFrame = startCFrame:Lerp(endCFrame, alpha)
	end

	-- Destruir copia al llegar
	if copy and copy.Parent then
		copy:Destroy()
	end
end

UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end

	if input.KeyCode == Enum.KeyCode.R then
		createCopyAndAnimate()
	end
end)
